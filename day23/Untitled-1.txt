const dist = ([x1, y1, z1], [x2, y2, z2]) => Math.abs(x1 - x2) + Math.abs(y1 - y2) + Math.abs(z1 - z2);

const overlaps = (p1, p2) => dist(p1, p2) <= p1[3] + p2[3];

const contains = ([bx, by, bz, bs], [sx, sy, sz, sr]) => {
  return [
    [bx, by, bz],
    [bx, by + bs, bz],
    [bx + bs, by, bz],
    [bx + bs, by + bs, bz],
    [bx, by, bz + bs],
    [bx, by + bs, bz + bs],
    [bx + bs, by, bz + bs],
    [bx + bs, by + bs, bz + bs]
  ].some(p => dist(p, [sx, sy, sz]) <= sr) ||
    [
      [sx + sr, sy, sz],
      [sx - sr, sy, sz],
      [sx, sy + sr, sz],
      [sx, sy - sr, sz],
      [sx, sy, sz + sr],
      [sx, sy, sz - sr],
    ].some(p => p[0] >= bx && p[0] <= bx + bs &&
      p[1] >= by && p[1] <= by + bs &&
      p[2] >= bz && p[2] <= bz + bs)
}

module.exports = input => {
  const nanobots = input.split('\n')
    .map(e => /pos=<(-?\d+),(-?\d+),(-?\d+)>, r=(\d+)/.exec(e))
    .map(e => e.slice(1).map(Number));

  let minx = miny = minz = 0;//Number.MAX_SAFE_INTEGER;
  let maxx = maxy = maxz = 0;
  //-Number.MAX_SAFE_INTEGER;

  const count = p => nanobots.filter(n => dist(p, n) <= n[3]).length;

  const countb = box => nanobots.filter(n => contains(box, n)).length;

  const find = (bx, by, bz, bs) => {
    if (bs == 1) {
      console.log('r', count([bx, by, bz]));
      return [bx, by, bz];
    }

    let sectors = [];

    const mx = (bx + bs) / 2;
    const my = (by + bs) / 2;
    const mz = (bz + bs) / 2;

    sectors.push([bx, by, bz, bs / 2]);
    sectors.push([mx, by, bz, bs / 2]);
    sectors.push([bx, my, bz, bs / 2]);
    sectors.push([mx, my, bz, bs / 2]);

    sectors.push([bx, by, mz, bs / 2]);
    sectors.push([mx, by, mz, bs / 2]);
    sectors.push([bx, my, mz, bs / 2]);
    sectors.push([mx, my, mz, bs / 2]);

    let mp = null;
    let m = 0;
    for (let [px1, py1, pz1, ps1] of sectors) {


      let c = countb([px1, py1, pz1, ps1]);
      console.log(c);
      //if (c == m) {
      //  console.log(c);
      // }
      if (c > m) {
        m = c;
        mp = [px1, py1, pz1, ps1];
      }
    }
    console.log('best', m, mp);
    //console.log(find(px1, py1, pz1, ps1));
    return find(...mp);
  }

  const overlapping = new Map();
  nanobots.forEach(n => overlapping.set(n, []));

  for (let i = 0; i < nanobots.length - 1; i++) {
    for (let j = i + 1; j < nanobots.length; j++) {
      if (overlaps(nanobots[i], nanobots[j])) {
        overlapping.get(nanobots[i]).push(nanobots[j]);
        overlapping.get(nanobots[j]).push(nanobots[i]);
      }
    }
  }

  let u = 0//-200000000;
  return find(u, u, u, 64);//20 * (2 ** 20));
  //console.log(Math.min(...[...overlapping.values()].map(o => o.length)));

  let mn = null;
  let mc = 0;
  for (let [x, y, z, r] of nanobots) {
    let vertices = [
      [x + r, y, z],
      [x - r, y, z],
      [x, y + r, z],
      [x, y - r, z],
      [x, y, z + r],
      [x, y, z - r]
    ]

    for (let v of vertices) {
      let c = count(v);

      if (c > mc) {
        mc = c;
        mn = v;
      }
    }
  }

  console.log(mc);

  let vertices = [
    [1, 0, 0],
    [1, 1, 0],
    [1, -1, 0],
    [1, 1, 1],
    [1, 1, -1],
    [1, -1, 1],
    [1, -1, -1],

    [-1, 0, 0],
    [-1, 1, 0],
    [-1, -1, 0],
    [-1, 1, 1],
    [-1, 1, -1],
    [-1, -1, 1],
    [-1, -1, -1],

    [0, 1, 0],
    [0, -1, 0],
    [0, 1, 1],
    [0, 1, -1],
    [0, -1, 1],
    [0, -1, -1],

  ]

  let d = dist([0, 0, 0], mn);

  for (let [dx, dy, dz] of vertices) {
    let [px, py, pz] = mn;
    do {
      px += dx;
      py += dy;
      pz += dz;

      if (count([px, py, pz]) == mc) {
        console.log(dx, dy, dz);
      }

    } while (count([px, py, pz]) == mc && dist([0, 0, 0], [px, py, pz]) <= d);

    console.log(count([px, py, pz]), dist([0, 0, 0], [px, py, pz]));
  }

  return dist([0, 0, 0], mn);
  //  const max = nanobots.reduce((max, curr) => curr[3] > max[3] ? curr : max);

  //  return nanobots.filter(n => dist(max, n) <= max[3]).length;
}